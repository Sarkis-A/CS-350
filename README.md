# CS-350
## Emerging Sys Arch &amp; Tech

In this course, I focused on emerging systems architectures and technologies, and two projects particularly highlight my capabilities: the Morse Code Communication System and the Thermostat State Machine.

The Morse Code project addressed the challenge of communicating messages visually using LED signals, translating text into Morse code with precise timing and LED control. On the other hand, the Thermostat project tackled temperature regulation through a state machine, which managed heating and cooling states, provided visual indicators, and communicated status updates to a server.

I excelled in structuring and implementing robust state machines for both projects. In the Morse Code project, I effectively handled state transitions and ensured precise LED timings to represent Morse signals accurately. Similarly, in the Thermostat project, I managed state transitions based on temperature thresholds and user input, guaranteeing reliable thermostat operation.

One area for improvement is the integration of enhanced error handling and input validation mechanisms to ensure greater reliability in the face of unexpected scenarios or erroneous input. Additionally, incorporating more unit testing and simulation tools into my development process would strengthen the robustness of future systems.

Throughout these projects, I expanded my support network by leveraging libraries such as gpiozero for hardware control and state machine for managing state transitions clearly and maintainable. These libraries simplify hardware interactions and promote a clear, maintainable software design.

The skills I developed in state machine implementation, precise timing control, and hardware-software interfacing are particularly transferable to other embedded system projects and coursework involving real-time control and IoT applications. Managing state-based logic, accurate event timing, and debugging hardware interfaces are broadly applicable across various technological contexts.

To ensure my code is maintainable, readable, and adaptable, I structured it clearly with meaningful class and method definitions, well-documented state transitions, and descriptive debug outputs. Consistently using classes, modular functions, and clear state definitions ensures that future modifications and maintenance tasks can be conducted efficiently and accurately.
